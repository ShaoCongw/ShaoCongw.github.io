---
layout:     post
title:      剑指offer阅读
subtitle:   阅读心得及例题
date:       2020-02-1
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 面试
    - 剑指offer
    - 算法
---

# 概览

重视**算法**，**数据结构**等基础知识

对项目充分熟悉

准备好对面试官的问题



编程题注意事项

**单元测试**，代码**调试能力**



简历中介绍项目的技巧：star

**situation**：项目背景，是什么

**task**：我的任务是什么，负责？参与？

**action**：**我做了什么，怎么做的**

**result：结果**（面试叙述时更重要）



**面试官提问**

项目中遇到的最大问题

从项目中学到了什么



**Q&A**

Q：为什么跳槽？

A：原工作已经做了一段时间，没有激情，想要换一份更有挑战性的工作



**查找，排序算法**

二分查找，	归并排序，快速排序

动态规划，贪婪算法



代码鲁棒性很重要：边界输入，特殊输入（NULL、空字符串），溢出，错误处理



# 程序设计题

## 2：单例模式

见博客单例模式

## 3.二维数组查找指定数

```java
public static boolean search(int[][] a, int goal) {
    boolean result = false;

    if (a != null) {
        int rows = a.length;//数组的行数
        int cols = rows == 0 ? 0 : a[0].length;//数组的列数
        if (rows > 0 && cols > 0) {
            int rowIndex = 0;
            int colIndex = cols - 1;//从右上角开始搜索

            while (rowIndex < rows && colIndex >= 0) {
                if (a[rowIndex][colIndex] == goal) {
                    result = true;
                    break;
                } else if (a[rowIndex][colIndex] > goal) {
                    //如果右上角的数字大于目标数字，直接砍掉最右侧一列
                    colIndex--;
                } else {
                    //如果右上角数字小于目标数字，砍掉最顶上一行
                    rowIndex++;
                }
            }
        }
    }
    return result;
}
```

## **4.字符串空格替换为“%20”**

传统的从头扫描字符串解法：每扫描到空格即在空格处添加“%20”，后面元素后移，时间复杂度为O(n2)

解法2：

事先计算新字符串的长度，有一个空格则长度要+2，然后在原字符串中从后向前复制，时间复杂度为O(n)

StringBuffer,StringBuilder从前往后append有取巧嫌疑，这里不采用

```java
public static String replace(String s){
    if (s == null){
        return null;
    }
    int blankNum = 0;//原字符串中空格的个数
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == ' '){
            blankNum++;
        }
    }
    int newLength = s.length() + blankNum * 2;//新字符串的长度
    char[] newStrings = new char[newLength];
    //设置新旧两个下标，分别指向新旧两个字符串的末尾，从后向前复制，时间复杂度为O(n)
    int oldIndex = s.length() - 1;
    int newIndex = newLength - 1;
    while (oldIndex >= 0){
        if (s.charAt(oldIndex) == ' '){
            newStrings[newIndex--] = '0';
            newStrings[newIndex--] = '2';
            newStrings[newIndex--] = '%';
        }else{
            newStrings[newIndex--] = s.charAt(oldIndex);
        }
        oldIndex--;
    }
    return String.valueOf(newStrings);
}
```

**拓展题目：**

有两个排序的数组A1和A2，内存在A1的末尾有足够多的内存空间容纳A2。请实现一个函数，把A2中的所有数字插入到A1并且所有数字是排序的。

```java
public static void merge(int[] a, int[] b){
    int aIndex = 0;
    for (int i = 0; i < a.length - 1; i++) {
        if (a[i] < a[i + 1]){
            aIndex++;
        }else{
            break;
        }
    }
    int bIndex = b.length - 1;
    int newIndex = aIndex + b.length;
    while (aIndex >= 0 && bIndex >= 0){
        if (a[aIndex] < b[bIndex]){
            a[newIndex--] = b[bIndex--];
        }else {
            a[newIndex--] = a[aIndex];
            aIndex--;
        }
    }
    //如果aindex > 0即b数组已全部填充进a数组，a数组不用做任何处理
    //反之，需要把b数组剩下的元素全部填充到a数组里
    while (bIndex >= 0){
        a[newIndex--] = b[bIndex--];
    }
}
```

测试数据

```
int[] a = {0,1, 4, 9, 13, 14,19, 0, 0, 0, 0, 0, 0};
int[] b = {6,7,8,20};
```

## 5.从尾到头打印链表

很明显是一个先进后出的问题，和栈有关，而**递归**本质上就是一个栈结构

链表结构：（包含头指针）

```java
/**
 * 实现一个不带头指针的链表
 */
class MyLinkList {
    Node head = null;//头节点
    int size = 0;

    //头插法建立链表
    public void addHead(int data) {
        if (head == null) {
            head = new Node(data);
        } else {
            Node node = new Node(data);
            node.next = head;
            head = node;
        }
        size++;
    }

    //尾插法建立链表
    public void addTail(int data) {
        Node node = new Node(data);
        if (head == null) {
            head = node;
        }else{
        	Node temp = head;
       		while (temp.next != null) {
            	temp = temp.next;
       		}
        	temp.next = node;
        }
        size++;
    }

    //在任意位置插入节点
    public void addPos(int data, int pos) {
        if (head == null) {
            head = new Node(data);
            return;
        }
        if (pos < 1 || pos > size + 1) {
            System.out.println("插入位置不合法");
            return;
        }
        if (pos == 1) {
            addHead(data);
        } else {
            Node temp = head;
            Node node = new Node(data);
            for (int i = 1; i < pos - 1; i++) {
                temp = temp.next;
            }
            node.next = temp.next;
            temp.next = node;

        }
        size++;

    }

    //从头到尾打印链表
    public void printHead() {
        if (head == null) {
            return;
        }
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + ",");
            temp = temp.next;
        }
    }

    //从尾到头打印链表
    public void printTail(Node head){
        if (head.next == null){
            System.out.print(head.data + ",");
        }else{
            printTail(head.next);
            System.out.print(head.data + ",");
        }
    }
    
    //打印倒数第i的节点
    public void printPos(int k) {
        if (k > size || k < 1) {
            System.out.println("参数不合法");
            return;
        }
        if (head != null) {
            Node p = head;
            Node q = head;
            //q指针先走k-1步
            for (int i = 0; i < k - 1; i++) {
                if(q.next!=null){
                	q = q.next;
                }
            }
            while (q.next != null) {
                q = q.next;
                p = p.next;
            }
            System.out.println(p.data);
        }
    }
        
        //反转链表，利用三个指针
    public void reverseList(){
        if (head == null){
            return;
        }
        Node currentNode = head;//当前遍历的节点
        Node preNode = null;//当前遍历节点的前一个节点
        Node nextNode = null;//当前遍历节点的后一个节点
        while (currentNode != null){
            nextNode = currentNode.next;
            currentNode.next = preNode;
            //preNode和currentNode向前推进
            preNode = currentNode;
            currentNode = nextNode;
        }
        //preNode最终指向最后一个节点，currentNode为null
        head = preNode;

    }

    class Node {
        int data;
        Node next;

        Node(int data) {
            this.data = data;
        }
    }

}
```

还利用java已有的stack，从头到尾将节点值push，最后在一一pop即可

## 二叉树前序，中序，后序遍历的6种实现

```java
class TreeUnit{
    TreeNode root; //根节点

    //
    class TreeNode{
        int data;
        TreeNode left ;
        TreeNode right ;
        public TreeNode(int data){
            this.data = data;
        }
    }
}
```

**递归法**（最简单）

```java
//递归法前序遍历
public void preOrderTraversal(TreeNode root){
    if (root == null){
        return;
    }
    System.out.println(root.data);
    preOrderTraversal(root.left);
    preOrderTraversal(root.right);
}
```

```java
//递归法中序遍历
public void midOrderTraversal(TreeNode root){
    if (root == null){
        return;
    }
    midOrderTraversal(root.left);
    System.out.println(root.data);
    midOrderTraversal(root.right);
}

```

```java
//递归法后序遍历
public void nextOrderTraversal(TreeNode root){
    if (root == null){
        return;
    }
    nextOrderTraversal(root.left);
    nextOrderTraversal(root.right);
    System.out.println(root.data);
}
```

递归法只是简单地调整了访问顺序

**非递归法**

```java
/**
 * 非递归前序遍历，需要使用栈辅助，循环
 * 1.访问当前节点，并把结点node入栈，当前结点置为它的左孩子；
 * 2.若当前节点为空，出栈，当前节点置为出栈节点的右孩子
 * @param root
 */
public void preOrdertraversal2(TreeNode root){
    TreeNode treeNode = root;
    Stack<TreeNode> stack = new Stack<>();
    while (treeNode != null || !stack.empty()){
        if (treeNode != null){
            System.out.println(treeNode.data + " ");
            stack.push(treeNode);
            treeNode = treeNode.left;
        }else{
            treeNode = stack.pop().right;
        }
    }
}
```

```java
/**
 * 非递归中序遍历，一样先从左走到最后，打印，出栈顺序改变一下
 * @param root
 */
public void midOrderTraversal2(TreeNode root){
    TreeNode node = root;
    Stack<TreeNode> stack = new Stack<>();
    while (node != null || !stack.empty()){
        if (node != null){
            stack.push(node);
            node = node.left;
        }else{
            TreeNode temp = stack.pop();
            System.out.println(temp.data + " ");
            node = temp.right;
        }
    }
}
```

```java
/**
 *非递归后序遍历
 */
public void nextOrderTraserval2(TreeNode root){
    TreeNode cur = root;
    TreeNode pre = null;
    Stack<TreeNode> stack = new Stack<>();
    while (cur != null || !stack.empty()){
        if (cur != null){
            //向左走到尽头
            stack.push(cur);
            cur = cur.left;
        }else{
            TreeNode top = stack.peek();//栈顶元素不弹出
            if (top.right != null && top.right != pre){
                //存在右子树且未被访问，一般是访问用于中间节点时，如果符合先去访问右子树
                cur = top.right;
            }else{
                //不符合就直接访问中间节点了
                stack.pop();
                System.out.println(top.data + " ");
                pre = top;//记录上次访问的节点
                cur = null;
            }
        }
    }
}
```

**层次遍历**：使用队列实现

```java
//层次遍历
public void levelTraversal(TreeNode root){
    if (root == null){
        return;
    }
    TreeNode node;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()){
        node = queue.poll();
        System.out.print(node.data + " ");
        if (node.left != null){
            queue.add(node.left);
        }
        if (node.right != null){
            queue.add(node.right);
        }
    }
}
```

## 5.由前序遍历和中序遍历重建二叉树

解题思路：由前序遍历可知根节点，则在中序遍历中根节点左边的全是左子树，右边的全是右子树。使用递归建立二叉树

```java
public TreeNode construct(int[] preOrder, int[] inOrder){
    if (preOrder == null || inOrder == null || preOrder.length == 0 || inOrder.length == 0 || preOrder.length != inOrder.length){
        return null;
    }
    return constructCore(preOrder, inOrder);
}
```

```java
public TreeNode constructCore(int[] preOrder, int[] inOrder){
    TreeNode root = new TreeNode(preOrder[0]);
    if (preOrder.length == 1){
        return new TreeNode(preOrder[0]);
    }
    int leftSize = 0;//左子树的节点个数
    for (int i = 0; i < inOrder.length; i++) {
        if (inOrder[i] == preOrder[0]){
            leftSize = i;
            break;
        }
    }
    int rightSize = inOrder.length - leftSize - 1;//右子树的节点个数
    //构建左子树
    if (leftSize > 0){
        root.left = constructCore(Arrays.copyOfRange(preOrder,1,leftSize+1)
                ,Arrays.copyOfRange(inOrder,0,leftSize));
    }
    //构建右子树
    if (rightSize > 0){
        root.right = constructCore(Arrays.copyOfRange(preOrder,leftSize+1,preOrder.length)
                ,Arrays.copyOfRange(inOrder,leftSize+1,inOrder.length));
    }
    return root;
}
```

## 7.用两个栈实现队列

```java
public class QueneUnit<T> {
    private Stack<T> stack1;
    private Stack<T> stack2;
    public QueneUnit(){
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    private void addTail(T t){
        stack1.push(t);
    }
    private T deleteHead(){
        if (isEmpty()){
            System.out.println("队列已为空");
        }
        if (stack2.empty()){
            while (!stack1.empty()){
                stack2.push(stack1.pop());
            }
        }
        T t = stack2.pop();
        return t;
    }
    private boolean isEmpty(){
       
       return stack1.empty() && stack2.empty();
    }
}
```

**拓展题目**：用两个队列实现栈



```java
public class StackUnit<T> {
    private Queue<T> queue1;
    private Queue<T> queue2;
    public StackUnit(){
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    public void push(T t){
        queue1.offer(t);
    }
    public T pop(){
        T t = null;
        if (isEmpty()){
            System.out.println("栈为空");
            return t;
        }
        //如果队列1是空的，说明元素全在队列2中，将队列2中除了队尾元素全部移动到队列1中，然后移除队列2队尾元素
        if (queue1.isEmpty()){
            int size = queue2.size();
            for (int i = 0; i < size - 1; i++) {
                queue1.offer(queue2.poll());
            }
            t = queue2.poll();
        }else{
            //如果quene1是非空的，则把除队尾元素的其他元素全部移动到quene2
            int size = queue1.size();
            for (int i = 0; i < size - 1; i++) {
                queue2.offer(queue1.poll());
            }
            t = queue1.poll();
        }
        return t;
    }
    public boolean isEmpty(){
        return queue1.isEmpty() && queue2.isEmpty();
    }
}
```

## 查找算法集合

**二分查找**O(logn)

```java
public static boolean binarySearch(int[] a, int k) {
        boolean find = false;
        if (a == null){
            return find;
        }
        int low = 0;
        int high = a.length - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (a[mid] == k) {
                find = true;
                break;
            } else if (a[mid] < k) {
                    low = mid + 1;
            }else{
                high = mid - 1;
        }
    }
        return find;

}
```

## 排序算法集合

**冒泡排序**O(n2)

```java
//冒泡排序
public static void bubbleSort(int[] a){
    //外层循环控制排序的趟数，每一趟排序把最大/小值一定到末尾
    for (int i = 0; i < a.length - 1; i++) {
        //内层循环控制每一趟需要比较的次数
        for (int j = 0; j < a.length - 1 - i ; j++) {
            if (a[j] > a[j+1]){
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}
```

**快速排序**O(n*logn)

```java
/**
 *
 * @param a
 * @param start 数组要排序的起止位置
 * @param end
 */
public static void quickSort(int[] a,int start, int end){
    if (start > end){
        return;
    }
    int temp = a[start];//基数
    int i = start;
    int j = end;
    while (i < j){
        //从右到左寻找第一个小于基数的数
        while (a[j] >= temp && i < j){
            j--;
        }
        //从左到右寻找第一个大于基数的数
        while (a[i] <= temp && i < j){
            i++;
        }
        if (i < j){
           int num = a[i];
           a[i] = a[j];
           a[j] = num;
        }
    }
    a[start] = a[i];
    a[i] = temp;
    quickSort(a, start, i - 1);
    quickSort(a, i+1, end);
}
```

https://blog.csdn.net/qq_37856300/article/details/83004642

如果基数要求随机选择数组中的一个数，只需要在最后交换的时候将i与基数的位置交换即可

也可先交换基数与数组第一个数的位置。然后其他不变

## **8.旋转数组的最小数字**

解题思路：二分查找

第一个指针总是指向第一个递增数组的元素，第二个指针总试想第二个递增数组的元素，最够第一个指针一定指向第一个递增数组的最后一个元素。第二个指针指向第二个递增数组的第一个元素，相差一个距离。index2就是最小元素

```java
public static int min(int[] a){
    if (a == null){
        throw new NullPointerException("输入数组为null");
    }
    int index1 = 0;//指向第一个元素
    int index2 = a.length - 1;//指向最后一个元素
    int midIndex = index1;
    while (a[index1] >= a[index2]){
        if (index2 - index1 == 1){
            //如果index2就在index1后面，index2一定是最小的元素
            midIndex = index2;
            break;
        }
        midIndex = (index1+index2)/2;
        //这里有特殊情况，index1和index2和midindex所指向的数全部相等，
        // 此时无法判断midindex是在前还是后一个子数组，如{1，0，1,1,1}和{1,1,1,0,1}
        // ，只能采取顺序判断
        if (a[index1] == a[index2] && a[index2] == a[midIndex]){
                return minOrder(a,index1,index2);
        }
        if (a[midIndex] >= a[index1]){
            index1 = midIndex;
        }else if (a[midIndex] <= a[index2]){
            index2 = midIndex;
        }
    }//特殊情况，移动的0个元素到尾部。因此，
    // 如果第一个第一个元素比最后一个元素小，则原数组没有变化
    // ，最小元素一定是第一个元素，所以midIndex初始化为index1；
    return a[midIndex];
}
//顺序查找
public static int minOrder(int[] a,int start, int end){
    int min = a[start];
    for (int i = start + 1; i <= end ; i++) {
        if (a[i] < min){
            min = a[i];
        }
    }
    return min;
}
```

## 9.斐波那契数列的循环解法

```java
public static long fib(int n) throws Exception {
    if (n >= 0 && n < 2){
        return n;
    }else if (n < 0){
        throw new Exception("输入的参数有误");
    }else{
        long fibOne = 1;//当前位置的前一个数
        long fibTwo = 0;//当前位置的后一个数
        long result = 0;
        for (int i = 2; i <= n ; i++) {
            result = fibOne + fibTwo;
            //把算出来的值存起来
            fibTwo = fibOne;
            fibOne = result;
        }
        return result;
    }
}
```

**相关题目**

**1，一只青蛙一次可以跳1级台阶，也可以跳两级，跳上一个n级台阶有多少种方法？**

当n = 1是，f(1) = 1;

继续推：f(2) =2 

​               f(3) = f(3-1)+f(3-2)

​              f(4) = f(4-1)+f(4-2)

当台阶数为n（n > 2）时：如果第一步选择了跳1级，那么跳法数量右n-1级决定

如果选择了跳2级，那么跳法数量为f(n-2)

f(n) = f(n-1) + f(n-2)

其实就是斐波拉契数列

**改一下**，青蛙可以跳1级，2级，，，n级。则跳上一个台阶有多少种

f（1） = 1；

f(2) = f(1) + 1;

f(3) = f(2) + f(1) + 1;

道理同上，第一步可以先跳1级，剩下f(n-1)

也可以先跳2级，剩下f(n-2)

....

先跳n-1级，剩下f（1） = 1

最后先n级，直接跳完，只有一种跳法

f(n) = f(n-1)+f(n-2)+...+f(n-(n-1))+1 = f(1)+f(2)+f(3)+f(4)+...+f(n-1) = 2**（n-1）

**2.矩形覆盖**，**用2x1的小矩形无重叠去覆盖2x8的大矩形有几种方案**

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbp2ht0vg9j30j5046a9y.jpg)

首先，把覆盖2*8的大矩形记为f(8)

不难得出：

f（1） = 1；

f(2) = 2;

当用2x1矩形覆盖大矩形左侧时，有两种覆盖方法：

**竖着放**，那么还剩2x7的矩形未覆盖f(7)

**横着放，**可知左下角必须再横着放一个2x1的小矩形才不会重叠，则还剩2x6的矩形未覆盖，f（6）

得出：f(8) = f(7)+f(6),又是斐波拉切数列问题

## **10.**二进制中1的个数

先看一个小例子

在excel中，用A表示第1列，B表示第2列，C表示第3列。。。。Z表示26列，AA表示27列，AB表示28列，以此类推。输入字符，输出10进制列数。

这是一个进制转换的问题，关键在于把10进制数字用A-Z表示成26进制

```java
public static int getCol(String s){
    //匹配输入字符全为大写
    if (!s.matches("[A-Z]+")){
        return -1;
    }
    char[] chars = s.toCharArray();
    int col = 0;
    for (int i = 0; i < chars.length; i++) {
        col += ((int) chars[i] -64)*Math.pow(26,chars.length-1-i);
    }
    return col;
}
```

**题目：**输入一个整数，输出该数二进制表示中1的个数

```java
public static int numberOf1(int n){
    int count = 0;
    while (n != 0){
        count++;
        n = n&(n-1);
    }
    return count;
}
```

一个整数减去1一定会把二进制表示中最右边的1变为0，再与原来的整数与运算，结果原整数第一个1的位置和右边全部变为0。

**相关题目：**

**用一条语句判断一个数是不是2的整数次方。**

如果一个整数是2的整数次方，那么二进制表示一定只有一个1，运用上面的只是，可知减去1再与原来的数与操作，结果必为0；

**输入两个整数m，n。计算需要改变m二进制表示中的几位才能变为n**

先将两个数异或操作，统计结果中1的个数，又变为12题的问题了