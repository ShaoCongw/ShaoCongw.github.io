---
layout:     post
title:      剑指offer阅读
subtitle:   第11题-20题
date:       2020-02-1
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 面试
    - 剑指offer
    - 算法
---

# 11.数值的整数次方

不得使用库函数，不考虑大数情况

**一般解法**

```java
public static double pow(double base, int exponent) throws Exception {
    if (base == 0 && exponent < 0){
        throw new Exception("输入不合法");
    }
    double result = powerWithExponent(base,Math.abs(exponent));
    if (exponent < 0){
        result = 1 / result;
    }
    return  result;
}
public static double powerWithExponent(double base, int exponent){
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}
```

**缺点：要做指数次乘法**

**优化代码**

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbqenkx47aj30hh03y0st.jpg)

运用递归，可以大大减少乘法的次数

修改powerWithExponent函数如下

```java
public static double powerWithExponent(double base, int exponent){
    double result = 1.0;
    if (exponent == 0){
        return 0;
    }
    if (exponent == 1){
        return base;
    }
    result = powerWithExponent(base, exponent >> 1);
    result *= result;
    //判断是不是奇数，奇数好药再乘一次
    if ((exponent & 1) == 1){
        result *= base;
    }
    return result;
}
```

- 用右移1位操作比除以2更快

- 用与操作比%2更快

# 12.打印从1到最大的n位数

**陷阱**：数值过大，必须考虑大数问题

使用递归法

```java
public static void print1ToMaxOfDigit(int n){
    if (n <= 0){
        return;
    }
    char[] digits = new char[n];
    print1ToMaxOfDigit(digits,0);
}
public static void print1ToMaxOfDigit(char[] number, int digit){
    if (digit == number.length){
        printNumber(number);
        return;
    }
    //循环给数组第digit位设置数字
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfDigit(number,digit+1);
    }
}
public static void printNumber(char[] number){
    int index = 0;
    //找到第一个不为0的字符，从这里开始打印
    while (index <number.length && number[index] == '0'){
        index++;
    }
    while (index < number.length){
        System.out.print(number[index]);
        index++;
    }
    System.out.println();
}
```

**拓展：**设计任意两个整数相加，同样要考虑大数类型

# 13.在O(1)事件内删除节点

**给定头指针和要删除的节点指针**

思路：既然给定了要删除的指针，只需把删除节后的后一个节点的值赋给待删除节点，然后删除后一个节点，达到了同样的效果还不用遍历链表，但要注意特殊情况；

**要删除的节点在链表尾部；**

**链表只有一个节点并且是要删除的节点**

```java
public static Node deleteNode(Node head, Node deleteNode){
    if (head == null || deleteNode == null){
        throw new NullPointerException("头指针或删除节点指针为空！");
    }
    if (deleteNode.next != null){
        //不是最后一个节点
        Node nextNode = deleteNode.next;
        deleteNode.value = nextNode.value;
        deleteNode.next = nextNode.next;
    }else if (head == deleteNode){
       //链表中只有一个节点，且恰好是要删除的节点
        head = null;
    }else{
        //链表中有多个节点，只能从头开始遍历，删除
        Node temp = head;
        while (temp.next != deleteNode){
            //找到待删除节点的前一个节点
            temp = temp.next;
        }
        temp.next = null;

    }
    return head;
}
static class Node{
    int value;
    Node next;
    public Node(int value){
        this.value = value;
    }
}
```

