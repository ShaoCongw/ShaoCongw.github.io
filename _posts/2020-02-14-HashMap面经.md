---
layout:     post
title:      HashMap面经
subtitle:   
date:       2020-02-14
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
    - 面经
---

在jdk1.7中和jdk1.8中HashMap的实现有所不同

# JDK1.7

JDK1.7中是通过**数组**（Entry<K,V>）+**链表**方式实现的

## 构造方法

首先从构造方法开始

```java
HashMap<String , String> hashMap = new HashMap<>();
```



进入HashMap的源代码可以发现这几个常量

最上面有一行注释没有截到，说得是初始容量必须是2的整数幂，后面也会验证这点

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw74zg9vgj30om0dxaaw.jpg)

分别是**数组的初始容量16**，**不是H**ashMap的容量大小

**数组最大总量**2的30次方

**默认负载因子**0.75

阈值**int threshold**，即数组的实际大小

**无参构造方法**

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw78tzcotj30gy027js1.jpg)

接着会调用有参构造方法，做一些参数判断处理

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw7a44hdfj30k408jn0m.jpg)

**注意，这个构造方法是public的，意味着我们可以自定义数组容量和负载因子来初始化HashMap**

init方法只是个空方法，是给子类覆写的，比如LinkedHashMap

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw7gi05yyj30ir01ewef.jpg)



## Put方法

**接下来看看put方法**

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw7tmis7wj30kd0ctq6m.jpg)

**首先判断Entry数组是不是空数组**

EMPTY_TABLE = {}

如果是空的要先初始化数组，调用inflateTable方法，传入我们的阈值，即最开始定义的数组大小，默认为16

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw7x7fhjbj30kv06mjth.jpg)

在该方法中首先对数组大小做了处理，找到一个大于或等于toSize的2的整数幂，这里验证了构造方法提到的数组大小应该为2的整数幂

然后真正初始化了数组

initHashSeedAsNeeded方法与扩容有关，我们这里先不管



**回到put方法**

我们可以看到，**key值是可以为null的**，并进行特殊处理putForNullKey方法

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw83e3tzfj30g4099tb4.jpg)





**hash方法**

然后进入hash方法，传入key值，得到需要的hash值

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw8jvyy9zj30j5089go4.jpg)

可以看到调用了对象的hashcode方法，但不是直接返回值，**还做了一些移位，异或处理**。这里暂且猜测是为了保证返回的hash值有足够的**散列性**，因为我们可能会重写类的hashCode方法导致了得到的值散列性不佳，会对hashmap造成性能损耗

**indexFor方法**

传入得到的hash值以及数组长度，得到对应的数组下标

![](http://ww1.sinaimg.cn/large/006nwaiFly1gbw8pxrpqyj30no0540tu.jpg)

可以看到，并不是我们猜测的通过**取余**运算得到下标，而是通过**与运算**，这里终于可以回答为什么数组长度要是2的整数幂了。

以默认长度16为例，二进制表示为**0001 0000**

减1后为15，二进制表示为**0000 1111**

hash & 0000 1111 最终的结果一定在**0-15**。