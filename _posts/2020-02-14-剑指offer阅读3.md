---
layout:     post
title:      剑指offer阅读3
subtitle:   第21题-30题
date:       2020-02-14
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 面试
    - 剑指offer
    - 算法
---

# 21.包含Min函数的栈

完成一个栈结构，要求push，pop，min函数都是O（1）内完成

思路：第一时间会想到用一个成员变量保存min，每push一次更新min值。这样会有一个问题，如果恰好把最小值pop了，此时的min值应该变为次小值。而我们并没有存储次小值。

同样，如果再添加一个成员变量保存次小值，我们有会无法得到第三小值。因此，用变量保存最小值是不可行的。



考虑使用两个栈，一个数据栈，一个辅助栈。一个最小值变量。每次push都把当前最小值也push到辅助栈，这样数据栈和辅助栈的大小是一样的。且辅助栈的栈顶永远是最小值。pop的时候，辅助栈也要pop

```java
import java.util.Stack;

public class StackWithMin<T extends Comparable<T>>{
    private Stack<T> stack1; //数据栈
    private Stack<T> stack2; //辅助栈
    private T min; //当前最小值
    public StackWithMin(){
        stack1 = new Stack<>();
        stack2 = new Stack<>();
        T min = null;
    }
    public boolean isEmplty(){
        return stack1.isEmpty() && stack2.isEmpty();
    }
    public void push(T t){
        stack1.push(t);
        //第一次push
        if (min == null){
            min = t;
        }else if (min.compareTo(t) > 0){
            //有更小值
            min = t;
        }
        stack2.push(min);

    }
    public T pop(){
        if (isEmplty()){
            return null;
        }
        stack2.pop();
        return stack1.pop();
    }
    public T getMin(){
        if(stack2.isEmpty()){
            return null;
        }
        return stack2.peek();
    }
    public static void main(String[] args) {
        StackWithMin<Integer> stackWithMin = new StackWithMin<>();
        stackWithMin.push(3);
        stackWithMin.push(4);
        stackWithMin.push(2);
        stackWithMin.pop();
        System.out.println(stackWithMin.getMin());
    }
}
```



# 22.栈的压入，弹出序列

输入两个序列，第一个是压栈序列（不一定是一次性压入），第二个是弹出序列，判断该弹出序列是否正确

从出栈序列着手，如果栈顶元素刚好等于下一个要弹出的序列，直接弹出。否则把压栈序列中还没有压入的的数字包括要弹出的数字全部压栈，如果数字都压完了还没有找到下一个弹出的数字，就不是

```java
public static boolean isPopOrder(int[] push, int[] pop){
    boolean result = false;
    if (push != null && pop != null && push.length == pop.length && push.length > 0){
        Stack<Integer> stack = new Stack<>();
        int pushIndex = 0;
        int popIndex = 0;
        while (popIndex < push.length){
            //将弹出数字及它前面的数字全部压栈
            while (stack.isEmpty() || !stack.peek().equals(pop[popIndex])){
                if (pushIndex < push.length){
                    stack.push(push[pushIndex]);
                    pushIndex++;
                }else{
                    break;
                }
            }
            if (!stack.peek().equals(pop[popIndex])){
                break;
            }
            stack.pop();
            popIndex++;
        }
        if (stack.isEmpty() && popIndex == pop.length){
            result = true;
        }
    }
    return result;
}
```

# 23.层次遍历二叉树

```java
public static void levelTraversla(TreeNode root){
    if (root == null){
        return;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()){
        TreeNode temp = queue.poll();
        System.out.print(temp.value+" ");
        if (temp.left != null){
            queue.add(temp.left);
        }
        if (temp.right != null){
            queue.add(temp.right);
        }
    }
}
```

# 24.二叉搜索树的后序遍历

输入一个序列，判断是否是二叉搜索树的后序遍历

**二叉搜索树**：其左子树存在，则其左子树中每个节点的值都不大于该节点值；

其右子树存在，则其左子树中每个节点的值都不小于该节点值；

序列最后一个元素一定是根点，前面的元素一部分是左子树，一部分是右子树。左子树不大于根节点，右子树不小于根节点。如果没有问题再递归检查左右子树

```java
public static boolean isPostTraversal(int[] a ,int start ,int end){
    if (a == null || a.length == 0){
        return false;
    }
    int root = a[end];//后序遍历，根节点一定是最后一个元素
    int rightIndex = start;//第一个右子树元素的下标
    for (; rightIndex < end; rightIndex++) {
        if (a[rightIndex] > root){
            break;
        }
    }
    //先检查右子树是否全部大于根节点，不是直接返回false
    for (int i = rightIndex; i < end; i++) {
        if (a[i] < root){
            return false;
        }
    }
    //如果左右子树元素符合要求，递归检查左右子树
    boolean left = true;
    boolean right = true;
    if (rightIndex > start){
        left = isPostTraversal(a,start,rightIndex - 1);
    }
    if (rightIndex < end){
        right = isPostTraversal(a,rightIndex,end - 1);
    }
    return left && right;

}
```

相关题目。如果改为**前序**呢

只需要改几个参数即可

```java
public static boolean isPreTraversal(int[] a ,int start ,int end){
    if (a == null || a.length == 0){
        return false;
    }
    int root = a[start];//后序遍历，根节点一定是最后一个元素
    int rightIndex = start+1;//第一个右子树元素的下标
    for (; rightIndex <= end; rightIndex++) {
        if (a[rightIndex] > root){
            break;
        }
    }
    //先检查右子树是否全部大于根节点，不是直接返回false
    for (int i = rightIndex; i <= end; i++) {
        if (a[i] < root){
            return false;
        }
    }
    //如果左右子树元素符合要求，递归检查左右子树
    boolean left = true;
    boolean right = true;
    if (rightIndex > start+1){
        left = isPreTraversal(a,start+1,rightIndex - 1);
    }
    if (rightIndex < end){
        right = isPreTraversal(a,rightIndex,end);
    }
    return left && right;

}
```

# 25.二叉树中和为某一值的路径

路径要求为根节点要叶节点，并打印出来

```java
public static void findPath(TreeNode root, int number){
    if (root == null){
        return;
    }
    int sum = 0;//当前累计总和
    List<TreeNode> path = new ArrayList<>();
    if (findPath(root,number,path,sum) == 0){
        System.out.println("未找到");
    }

}
```

```java
public static int findPath(TreeNode root, int number, List<TreeNode> path, int sum){
    sum += root.value;
    path.add(root);
    boolean isLeaf = root.left == null && root.right == null;
    if (isLeaf && sum == number){
        System.out.println(path.size());
        for (TreeNode node :path) {
            System.out.print(node.value+" ");

        }
        path.remove(path.size()-1);
        return 1;
    }
    int count = 0;
    //递归前序遍历
    if (root.left != null){
        count += findPath(root.left,number,path,sum);
    }
    if (root.right != null){
        count +=findPath(root.right, number, path, sum);
    }
    //离开该节点时，从路径中剔除
    path.remove(path.size()-1);
    //sum -= root.value;由于不是引用传递，所以不用减去当前值
    return count;
}
```

# 26复杂链表的复制

**首先说说这道题的常规解法**：

分为两步

- 先不管sibing节点，只复制next节点，即复制一条普通的链表
- 对于每一个节点，从表头开始寻找他的sibing节点，走了s步，则复制链表中也走s步，事件复杂度为O（n2）

**时间复杂度为O(n)的解法**，**用空间换时间**

用HashMap存储每个节点和其对应的复制节点，这样对于每个copyNode，可以在O(1)时间内获取到sibing节点，

**第三种解法**

把每一个复制节点插入到原节点的后面，这样找copyNode的sibing节点就是原节点sibing的next节点。最后拆分出copyList即可。

```java
public static ListNode copyComplexList(ListNode head){
    if (head == null){
        return null;
    }
    mergeList(head);
    connectSibing(head);
    return splitCopyNode(head);
}
//把复制的链表每个节点插在对应节点的后面
public static void mergeList(ListNode head){
    ListNode temp = head;
    while (temp != null){
        ListNode copyNode = new ListNode(temp.value);
        copyNode.next = temp.next;
        temp.next = copyNode;
        temp = copyNode.next;
    }
}
//给每个复制的节点设置sibing
public static void connectSibing(ListNode head){
    ListNode temp = head;
    ListNode copyNode = null;
    while (temp != null){
        copyNode = temp.next;
        if (temp.sibing != null){
            copyNode.sibing = temp.sibing.next;
        }
        temp = copyNode.next;
    }
}
//把复制节点拆分出来
public static ListNode splitCopyNode(ListNode head){
    ListNode copyHead = head.next;
    ListNode temp = head;
    ListNode copyNode = head.next;
    temp.next = copyNode.next;
    temp = copyNode.next;

    while (temp != null){
        copyNode.next = temp.next;
        copyNode = copyNode.next;
        temp.next = copyNode.next;
        temp = temp.next;
    }
    return copyHead;

}
```