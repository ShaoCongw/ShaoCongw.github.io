---
layout:     post
title:      剑指offer阅读4
subtitle:   第32题-42题
date:       2020-02-20
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 面试
    - 剑指offer
    - 算法
---

# 32，从1到n整数中1出现的次数

输入一个整数n，求从1到这个整数的10进制表示中一出现的次数

来自牛客网的推荐解答：https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?f=discussion

设定整数点i（1,10,100）等作为位置点，将数字n划分为两部分，高位**n/i,**(包括i这个数位)，低位**n % i**

分析使百位为1时有几种情况

- n的百位上的数字 **>= 2** ,比如n = **31456**。此时a = 314，b = 56；

  高位百位为1的次数有：a / 10 + 1 = 32 (0~31),低位100种情况（0~99），那么一共有

  (a / 100 +1) * i , 此时的i等于100

- n的百位上的数字  **== 1**，比如**n = 31156**。此时a = 311， b = 56；

  高位百位为1的次数有 a / 10 = 31 (0~30),这里能取31了，当百位为1时，后面两位最大才56，不能取到99，(a / 10) * i ,还要加上后面两位的情况，b+1，所以一共是**(a / 10) * i + （b+1）**

- n的百位数字 **== 0**，比如**n = 31056**，此时a = 310 ，b = 56。当百位是0，后面的低位显然没什么意义了，高位的次数为 a / 10 = 31 (0~30,不能取31)，一共有(a / 10) * i



这里有一个技巧不用是我们去单独判断 i 位置上的到底是不是 >= 2 ,可以（a+8 ) / 10,如果大于等于2，+8后自然会进位，不用+1. 。只需要判断i位置上是不是1即可

```java
public static int NumberOf1Between1AndN_Solution(int n) {
    int count = 0;
    for (int i = 1; i < n; i *= 10) {
        int a = n / i;
        int b = n % i;
        count += (a + 8)/10*i + (a % 10 == 1 ? b+1 : 0);
    }
    return count;
}
```

#  33,把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印拼接数最小的那个数。例如输入{3,32，321}，最小的数字为321323

最常规的做法是把所有数字全排列，然后比较得出最小的那个。这样时间复杂度为n！

关键在于自定义排序规则，将字符串数组排序，然后依次打印出来

```java
public static String getSortesStringArray(int[] n){
    String[] strings = new String[n.length];
    for (int i = 0; i < n.length; i++) {
        strings[i] = String.valueOf(n[i]);
    }
    Arrays.sort(strings, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            String temp = o1;
            o1 = o1 + o2;
            o2 = o2 + temp;
            return o1.compareTo(o2);
        }
    });
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < n.length; i++) {
        stringBuilder.append(strings[i]);
    }
    return stringBuilder.toString();
}
```

如果要求最大的数

只需要改变比较器，直接比较字符串第一位就行了，永远把大的放在前面

```java
new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            String temp = o1;
            o1 = o1 + o2;
            o2 = o2 + temp;
            return -o1.compareTo(o2);
        }
```

# 34.丑数

只包含因子2，3,5的数称为丑数，求从小到大的第1500个丑数，第一个丑数是1

常规思路一般是穷举法，对每一个数判断它是不是丑数。对每一个数都做判断损耗性能

```java
public static boolean isUglyNumber(int number){
    while (number % 2 == 0){
        number /= 2;
    }
    while (number % 3 == 0){
        number /= 3;
    }
    while (number % 5 == 0){
        number /= 5;
    }
    return number == 1;
}
```



**用空间换时间**

维护一个从小到大的丑数数组，下一个丑数一定是一定是前面某一个丑数乘以2或乘以3或乘以5的结果，得出的这些值中如果小于当前最大值，肯定已经加入到丑数数组了。我们只要大于当前最大值的结果。

我们也不必每次都从第一个数开始乘，维护是三个指针，分别是乘以2，乘以3，乘以5后大于当前最大值。从这三个结果中选取最下值作为下一个丑数。同时更新这三个指针

```java
public static int getUglyNumber(int index) {
    if (index <= 0) {
        return -1;
    }
    int[] uglyArray = new int[index];
    uglyArray[0] = 1;
    int nextIndex = 1;
    int mutiplay2 = 0;
    int mutiplay3 = 0;
    int mutiplay5 = 0;
    while (nextIndex < index) {
        uglyArray[nextIndex] = min(uglyArray[mutiplay2] * 2, uglyArray[mutiplay3] * 3, uglyArray[mutiplay5] * 5);
        //找到丑数数组中2倍大于当前最大值
        while (uglyArray[mutiplay2] * 2 <= uglyArray[nextIndex]) {
            mutiplay2++;
        }
        while (uglyArray[mutiplay3] * 3 <= uglyArray[nextIndex]) {
            mutiplay3++;
        }
        while (uglyArray[mutiplay5] * 5 <= uglyArray[nextIndex]) {
            mutiplay5++;
        }
        nextIndex++;
    }
    return uglyArray[index - 1];
}
```